package edu.jhu.cobra.framework

import kotlinx.coroutines.flow.FlowCollector
import kotlin.reflect.full.declaredMemberProperties
import kotlin.reflect.full.primaryConstructor

/**
 * Marker interface for products generated by a worker after performing a task.
 *
 * Implement this interface for any output type produced by [IWorker].
 */
interface IProduct

/**
 * Represents a unit of work that can be performed by a worker.
 *
 * Each task has a unique identifier ([uid]) for dispatching and mapping to workers.
 */
interface ITask {

    /**
     * Unique identifier for a task, consisting of a license and associated properties.
     *
     * @property license The license or type name for the task.
     * @property props The set of properties describing the task.
     */
    data class ID(val license: String, val props: Set<String>)

    /**
     * Unique identifier for the task instance.
     */
    val uid: ID
}

/**
 * Worker capable of performing a task and emitting products.
 *
 * @param T The type of task this worker can handle; must extend [ITask]. Non-null.
 * @param R The type of product this worker produces; must extend [IProduct]. Non-null.
 */
interface IWorker<T : ITask, R : IProduct> {
    /**
     * Performs the given task and emits results to the [FlowCollector].
     *
     * @param task The task to perform. Non-null.
     */
    suspend fun FlowCollector<R>.work(task: T)
}

/**
 * Annotation for marking classes, methods, or properties as licensed for specific tasks.
 *
 * Used to enforce or verify permissions and capabilities at runtime.
 */
@Target(AnnotationTarget.ANNOTATION_CLASS)
@Retention(AnnotationRetention.RUNTIME)
annotation class WorkLicense {
    companion object
}

/**
 * Returns a task ID from a [WorkLicense] annotation instance.
 *
 * @param annotation The annotation instance. Non-null.
 * @return The generated [ITask.ID].
 */
fun WorkLicense.Companion.getTaskID(annotation: Annotation): ITask.ID {
    val annoCls = annotation.annotationClass
    val annotatedProps = annoCls.primaryConstructor!!.parameters.map { it.name }
        .map { tar -> annoCls.declaredMemberProperties.first { it.name == tar } }
    val innerStr = annotatedProps.map { it.call(annotation).toString() }
    return WorkLicense.getTaskID(annotation.annotationClass.java, innerStr)
}

/**
 * Returns a task ID from a [WorkLicense] annotated class and props.
 *
 * @param cls The class associated with the task. Non-null.
 * @param props Vararg of properties to include in the task ID.
 * @return A new [ITask.ID] constructed from the provided class and properties.
 */
fun WorkLicense.Companion.getTaskID(cls: Class<*>, vararg props: String) =
    ITask.ID(cls.simpleName, props.toSet())

/**
 * Returns a task ID from a [WorkLicense] annotated class and props.
 *
 * @param cls The class associated with the task. Non-null.
 * @param props Collection of String to include in the task ID. Non-null.
 * @return A new [ITask.ID] constructed from the provided class and properties.
 */
fun WorkLicense.Companion.getTaskID(cls: Class<*>, props: Collection<String>) =
    ITask.ID(cls.simpleName, props.toSet())

/**
 * Checks if a given task ID matches a specified license class.
 *
 * @param taskID The task ID to check. Non-null.
 * @param forLicense The license class to compare against. Non-null.
 * @return True if the task ID corresponds to the given license class, false otherwise.
 */
fun WorkLicense.Companion.isTaskID(taskID: ITask.ID, forLicense: Class<*>) =
    taskID.license == forLicense.simpleName